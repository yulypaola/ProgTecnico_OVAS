<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Flipbook</title>
<style>
  :root{
    --bg:#111; --fg:#eaeaea; --muted:#9aa0a6; --accent:#3aa675;
    --shadow: 0 12px 36px rgba(0,0,0,.38);
    --flip-duration: 720ms;
    --fold-width: 24px;
    --zoom: 1;             /* zoom del usuario */
    --bar-h: 60px;
    --gap: 10px;           /* separaci√≥n entre p√°ginas */
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans";}
  .topbar{display:flex;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid #222;
    background:#0b0b0b;position:sticky;top:0;z-index:10;min-height:var(--bar-h)}
  .title{font-weight:600;letter-spacing:.2px}
  .spacer{flex:1}
  .controls{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
  button{background:#1b1b1b;border:1px solid #2a2a2a;color:var(--fg);padding:6px 10px;border-radius:8px;
    cursor:pointer;font-size:14px}
  button:hover:not(:disabled){border-color:var(--accent)}
  button:disabled{opacity:.45;cursor:not-allowed}
  .counter{color:var(--muted);font-size:14px;min-width:160px;text-align:right}

  .stage{position:fixed;top:var(--bar-h);left:0;right:0;bottom:0;display:grid;place-items:center;padding:0 8px}
  .book-wrap{transform:scale(var(--zoom)); transform-origin:center; transition:transform 120ms ease;}
  /* el tama√±o real (px) del libro lo fija JS con style.width/height */
  .book{display:grid;grid-auto-flow:column;grid-template-columns:auto auto;gap:var(--gap);
        perspective:2000px;align-items:stretch}
  .single .book{grid-template-columns:auto}

  .page{background:#000;border-radius:10px;overflow:hidden;position:relative;box-shadow:var(--shadow);
    display:grid;place-items:center}
  .page img{width:100%;height:100%;object-fit:contain;display:block;background:#fff}
  .page.blank{background:#0b0b0b} /* hoja vac√≠a (tapa izquierda) */

  .clickzone{position:absolute;top:0;bottom:0;width:25%}
  .clickzone.left{left:0;cursor:pointer}
  .clickzone.right{right:0;cursor:pointer}

  .flip-overlay{position:absolute;inset:0;transform-style:preserve-3d;pointer-events:none}
  .flip-overlay.animate{animation-duration:var(--flip-duration);animation-timing-function:ease-in-out}
  .flip-next.animate{animation-name:flipNext}
  .flip-prev.animate{animation-name:flipPrev}
  .face{position:absolute;inset:0;backface-visibility:hidden;display:grid;place-items:center;background:#000}
  .face img{width:100%;height:100%;object-fit:contain;background:#fff}
  .back{transform:rotateY(180deg)}

  .shadeL,.shadeR{position:absolute;top:0;bottom:0;width:var(--fold-width);pointer-events:none}
  .shadeL{left:0;background:linear-gradient(to right, rgba(0,0,0,var(--shadeL,0.45)) 0%, rgba(0,0,0,0) 100%)}
  .shadeR{right:0;background:linear-gradient(to left, rgba(0,0,0,var(--shadeR,0.45)) 0%, rgba(0,0,0,0) 100%)}

  /* Avanzar: hoja derecha ‚Üí izquierda */
  @keyframes flipNext{0%{transform:rotateY(0deg)}45%{transform:rotateY(-90deg)}100%{transform:rotateY(-180deg)}}
  @keyframes flipPrev{0%{transform:rotateY(0deg)}45%{transform:rotateY(90deg)}100%{transform:rotateY(180deg)}}

  @media (max-width:768px){.book{grid-template-columns:auto}}
</style>
</head>
<body>
  <div class="topbar" role="region" aria-label="Barra de navegaci√≥n del flipbook">
    <div class="title">Flipbook</div>
    <div class="controls" aria-label="Controles de navegaci√≥n">
      <button id="btnFirst" aria-label="Primera p√°gina">‚èÆ</button>
      <button id="btnPrev" aria-label="P√°gina anterior">‚óÄ</button>
      <button id="btnNext" aria-label="P√°gina siguiente">‚ñ∂</button>
      <button id="btnLast" aria-label="√öltima p√°gina">‚è≠</button>
    </div>
    <div class="controls" aria-label="Controles de zoom">
      <button id="btnZoomOut" aria-label="Reducir zoom">üîç‚àí</button>
      <button id="btnZoomReset" aria-label="Restablecer zoom">100%</button>
      <button id="btnZoomIn" aria-label="Aumentar zoom">üîçÔºã</button>
    </div>
    <div class="controls" aria-label="Reproducci√≥n autom√°tica">
      <button id="btnAuto" aria-label="Pase autom√°tico">Auto ‚ñ∂</button>
    </div>
    <div class="spacer"></div>
    <div id="counter" class="counter" aria-live="polite" aria-atomic="true"></div>
  </div>

  <div id="root" class="stage">
    <div class="book-wrap">
      <div id="book" class="book"></div>
    </div>
  </div>

<script>
/* ==== LISTA DE IM√ÅGENES ==== */
const IMAGES = [
  "img/page-001.png","img/page-002.png","img/page-003.png","img/page-004.png","img/page-005.png",
  "img/page-006.png","img/page-007.png","img/page-008.png","img/page-009.png","img/page-010.png",
  "img/page-011.png","img/page-012.png","img/page-013.png","img/page-014.png","img/page-015.png"
];

/* ====== Estado ====== */
let autoTimer = null;
let userZoom = 1, ZMIN=0.6, ZMAX=2.0, ZSTEP=0.1;
let ratio = 0.7071; // fallback; se recalcula con la primera imagen (w/h)

const root   = document.getElementById('root');
const wrap   = document.querySelector('.book-wrap');
const book   = document.getElementById('book');
const counterEl = document.getElementById('counter');
const btnFirst = document.getElementById('btnFirst');
const btnPrev  = document.getElementById('btnPrev');
const btnNext  = document.getElementById('btnNext');
const btnLast  = document.getElementById('btnLast');
const btnZoomIn = document.getElementById('btnZoomIn');
const btnZoomOut = document.getElementById('btnZoomOut');
const btnZoomReset = document.getElementById('btnZoomReset');
const btnAuto = document.getElementById('btnAuto');

function twoUp(){ return !window.matchMedia("(max-width: 768px)").matches; }
/* currentIndex:
   - m√≥vil: √≠ndice de p√°gina mostrada
   - desktop: √≠ndice de la P√ÅGINA IZQUIERDA; -1 = portada (izq vac√≠a + p√°g1 derecha) */
let currentIndex = twoUp() ? -1 : 0;

/* ====== Auto-fit: dimensiona libro en px y aplica escala para encajar ====== */
function applyAutoFit(){
  // dimensiones del viewport util
  const vw = root.clientWidth - 16;                 // 8px paddings
  const vh = root.clientHeight - 8;

  // Queremos definir un alto "base" de p√°gina (pageH) y ancho pageW = pageH * ratio
  // Para que TODO quepa: para 2 p√°ginas => (2*pageW + gap) <= vw  y pageH <= vh
  const GAP = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 10;

  let pageH_byHeight = vh; // limitar por alto
  let pageH_byWidth;

  if(twoUp()){
    pageH_byWidth = (vw - GAP) / (2 * ratio);
  }else{
    pageH_byWidth = vw / ratio;
  }

  const pageH = Math.max(100, Math.min(pageH_byHeight, pageH_byWidth)); // alto real de UNA p√°gina
  const pageW = pageH * ratio;

  // Asignar tama√±o real del "libro"
  if(twoUp()){
    book.style.width  = (pageW*2 + GAP) + "px";
    book.style.height = pageH + "px";
  }else{
    book.style.width  = pageW + "px";
    book.style.height = pageH + "px";
  }

  // Escala de usuario (zoom) ‚Äì SIEMPRE encaja porque el tama√±o base ya est√° ajustado
  document.documentElement.style.setProperty('--zoom', userZoom.toString());
}

/* ====== Zoom ====== */
function setZoom(val){ userZoom = Math.max(ZMIN, Math.min(ZMAX, val)); applyAutoFit(); }
btnZoomIn.onclick  = ()=> setZoom(userZoom + ZSTEP);
btnZoomOut.onclick = ()=> setZoom(userZoom - ZSTEP);
btnZoomReset.onclick = ()=> setZoom(1);

/* ====== Construcci√≥n de p√°ginas ====== */
function pageDiv(src, isBlank=false){
  const d=document.createElement('div');
  d.className='page' + (isBlank ? ' blank' : '');
  const img=new Image();
  img.loading='lazy'; img.decoding='async'; img.alt='P√°gina';
  if(!isBlank){ img.src=src; }
  d.appendChild(img);
  const L=document.createElement('div'); L.className='clickzone left';  L.onclick=goPrev;
  const R=document.createElement('div'); R.className='clickzone right'; R.onclick=goNext;
  d.appendChild(L); d.appendChild(R);
  setupDrag(d);
  return d;
}

function formatCounter(){
  const N = IMAGES.length;
  if(!twoUp()) return `P√°gina ${currentIndex+1} de ${N}`;
  if(currentIndex === -1) return `P√°gina 1 de ${N}`;
  const L = currentIndex + 1, R = Math.min(N, currentIndex + 2);
  return (L===R) ? `P√°gina ${L} de ${N}` : `P√°ginas ${L}‚Äì${R} de ${N}`;
}

function updateButtons(){
  const N = IMAGES.length;
  if(!twoUp()){
    btnFirst.disabled = currentIndex<=0;
    btnPrev.disabled  = currentIndex<=0;
    btnNext.disabled  = currentIndex>=N-1;
    btnLast.disabled  = currentIndex>=N-1;
    return;
  }
  btnFirst.disabled = currentIndex<=-1;
  btnPrev.disabled  = currentIndex<=-1;
  const atLast = (N%2===1) ? (currentIndex>=N-3) : (currentIndex>=N-2);
  btnNext.disabled  = atLast;
  btnLast.disabled  = atLast;
}

/* ====== Render ====== */
function renderSpread(){
  book.innerHTML='';
  if(!twoUp()){
    const idx = Math.max(0, currentIndex===-1?0:currentIndex);
    book.parentElement.parentElement.classList.add('single');
    book.classList.add('single');
    book.appendChild(pageDiv(IMAGES[idx]));
  }else{
    book.parentElement.parentElement.classList.remove('single');
    book.classList.remove('single');
    if(currentIndex === -1){
      book.appendChild(pageDiv('', true));       // izquierda vac√≠a (tapa)
      book.appendChild(pageDiv(IMAGES[0]));      // derecha p√°g. 1
    }else{
      book.appendChild(pageDiv(IMAGES[currentIndex])); // izquierda
      const r = currentIndex + 1;
      book.appendChild( r < IMAGES.length ? pageDiv(IMAGES[r]) : pageDiv('', true) ); // derecha o vac√≠a
    }
  }
  counterEl.textContent = formatCounter();
  updateButtons();
  applyAutoFit();
}

/* ====== Efecto flip (D‚ÜíI al avanzar) ====== */
function createFlipOverlay(frontSrc, backSrc, dir){
  const overlay=document.createElement('div');
  overlay.className='flip-overlay';
  overlay.style.setProperty('--shadeL','0');
  overlay.style.setProperty('--shadeR','0');

  const front=document.createElement('div'); front.className='face front';
  const fImg=new Image(); fImg.src=frontSrc; front.appendChild(fImg);

  const back=document.createElement('div'); back.className='face back';
  const bImg=new Image(); bImg.src=backSrc; back.appendChild(bImg);

  const shadeL=document.createElement('div'); shadeL.className='shadeL';
  const shadeR=document.createElement('div'); shadeR.className='shadeR';

  overlay.appendChild(front); overlay.appendChild(back);
  overlay.appendChild(shadeL); overlay.appendChild(shadeR);

  overlay.style.transformOrigin = (dir==='next') ? 'right center' : 'left center';
  overlay.dataset.dir = dir;
  return overlay;
}
let flipping=false;

function goNext(){
  if(flipping) return;
  if(!twoUp()){
    if(currentIndex >= IMAGES.length-1) return;
    flipSingle('next');
  }else{
    const maxLeft = (IMAGES.length % 2 === 0) ? (IMAGES.length - 2) : (IMAGES.length - 3);
    if(currentIndex >= maxLeft) return;
    if(currentIndex === -1) { flipCoverToFirst(); return; }
    flipDouble('next');
  }
}
function goPrev(){
  if(flipping) return;
  if(!twoUp()){
    if(currentIndex <= 0) return;
    flipSingle('prev');
  }else{
    if(currentIndex <= -1) return;
    if(currentIndex === 0) { flipFirstToCover(); return; }
    flipDouble('prev');
  }
}

function flipCoverToFirst(){
  flipping = true;
  const rightPage = book.children[1];
  const overlay = createFlipOverlay(IMAGES[0], IMAGES[1] || IMAGES[0], 'next');
  rightPage.appendChild(overlay);
  requestAnimationFrame(()=> overlay.classList.add('animate','flip-next'));
  overlay.addEventListener('animationend', ()=>{
    currentIndex = 1; renderSpread(); flipping=false;
  }, {once:true});
}
function flipFirstToCover(){
  flipping = true;
  const leftPage = book.children[0];
  const overlay = createFlipOverlay(IMAGES[1], IMAGES[0], 'prev');
  leftPage.appendChild(overlay);
  requestAnimationFrame(()=> overlay.classList.add('animate','flip-prev'));
  overlay.addEventListener('animationend', ()=>{
    currentIndex = -1; renderSpread(); flipping=false;
  }, {once:true});
}
function flipSingle(direction){
  flipping=true;
  const from = Math.max(0, currentIndex);
  const to   = clampIndex(currentIndex + (direction==='next'?1:-1));
  const page = book.querySelector('.page');
  const overlay = createFlipOverlay(IMAGES[from], IMAGES[to], direction==='next'?'next':'prev');
  page.appendChild(overlay);
  requestAnimationFrame(()=> overlay.classList.add('animate', direction==='next'?'flip-next':'flip-prev'));
  overlay.addEventListener('animationend', ()=>{
    currentIndex = to; renderSpread(); flipping=false;
  }, {once:true});
}
function flipDouble(direction){
  flipping=true;
  if(direction==='next'){
    const rightPage = book.children[1] || book.children[0];
    const fromFront = IMAGES[currentIndex+1] || IMAGES[currentIndex];
    const toBack    = IMAGES[currentIndex+2] || IMAGES[IMAGES.length-1];
    const overlay = createFlipOverlay(fromFront, toBack, 'next');
    rightPage.appendChild(overlay);
    requestAnimationFrame(()=> overlay.classList.add('animate','flip-next'));
    overlay.addEventListener('animationend', ()=>{
      currentIndex = clampIndex(currentIndex + 2);
      renderSpread(); flipping=false;
    }, {once:true});
  }else{
    const leftPage  = book.children[0];
    const fromFront = IMAGES[currentIndex];
    const toBack    = IMAGES[currentIndex-1];
    const overlay = createFlipOverlay(fromFront, toBack, 'prev');
    leftPage.appendChild(overlay);
    requestAnimationFrame(()=> overlay.classList.add('animate','flip-prev'));
    overlay.addEventListener('animationend', ()=>{
      currentIndex = clampIndex(currentIndex - 2);
      renderSpread(); flipping=false;
    }, {once:true});
  }
}

/* Drag */
function setupDrag(pageEl){
  let startX=null, dragging=false, overlay=null, dir=null, width=0;

  function onStart(ev){
    if(flipping) return;
    const rect=pageEl.getBoundingClientRect(); width=rect.width;
    const x=(ev.touches?ev.touches[0].clientX:ev.clientX)-rect.left;

    if(!twoUp()){
      dir = (x>rect.width*0.6) ? 'next' : (x<rect.width*0.4 ? 'prev' : null);
      if(!dir) return;
    }else{
      if(currentIndex === -1){
        if(pageEl===book.children[1] && x>rect.width*0.4) dir='next'; else return;
      }else{
        if(x>rect.width*0.6 && pageEl===book.children[1]) dir='next';
        else if(x<rect.width*0.4 && pageEl===book.children[0]) dir='prev';
        else return;
      }
    }

    startX = ev.touches?ev.touches[0].clientX:ev.clientX;
    dragging=true;

    if(!twoUp()){
      const from = Math.max(0, currentIndex);
      const to   = clampIndex(currentIndex + (dir==='next'?1:-1));
      overlay = createFlipOverlay(IMAGES[from], IMAGES[to], dir);
    }else{
      if(currentIndex === -1 && dir==='next'){
        overlay = createFlipOverlay(IMAGES[0], IMAGES[1]||IMAGES[0], 'next');
      }else if(dir==='next'){
        overlay = createFlipOverlay(IMAGES[currentIndex+1]||IMAGES[currentIndex], IMAGES[currentIndex+2]||IMAGES[IMAGES.length-1], 'next');
      }else{
        overlay = createFlipOverlay(IMAGES[currentIndex], IMAGES[currentIndex-1], 'prev');
      }
    }
    pageEl.appendChild(overlay);
    ev.preventDefault();
  }

  function onMove(ev){
    if(!dragging || !overlay) return;
    const clientX = ev.touches?ev.touches[0].clientX:ev.clientX;
    const delta = clientX - startX;
    let progress = Math.min(1, Math.max(0, Math.abs(delta)/ (width*0.9)));
    const angle = (dir==='next' ? -180 : 180) * progress;
    overlay.style.transform = "rotateY(" + angle + "deg)";
    const shade = 0.55 * progress;
    overlay.style.setProperty('--shadeL', dir==='prev' ? shade : 0);
    overlay.style.setProperty('--shadeR', dir==='next' ? shade : 0);
    ev.preventDefault();
  }

  function onEnd(ev){
    if(!dragging || !overlay) return;
    const endX = (ev.changedTouches?ev.changedTouches[0].clientX:ev.clientX) || startX;
    const moved = Math.abs(endX - startX);
    const willCommit = moved > (width * 0.35);
    if(willCommit){
      overlay.classList.add('animate', dir==='next'?'flip-next':'flip-prev');
      overlay.addEventListener('animationend', ()=>{
        if(!twoUp()){
          currentIndex = clampIndex(currentIndex + (dir==='next'?1:-1));
        }else if(currentIndex === -1 && dir==='next'){
          currentIndex = 1;
        }else{
          currentIndex = clampIndex(currentIndex + (dir==='next'?2:-2));
        }
        renderSpread(); flipping=false;
      }, {once:true});
      flipping=true;
    }else{
      overlay.style.transition='transform 280ms ease'; overlay.style.transform='rotateY(0deg)';
      setTimeout(()=>{ overlay.remove(); }, 300);
    }
    dragging=false; overlay=null; dir=null; startX=null;
    ev.preventDefault();
  }

  pageEl.addEventListener('mousedown', onStart);
  pageEl.addEventListener('touchstart', onStart, {passive:false});
  window.addEventListener('mousemove', onMove, {passive:false});
  window.addEventListener('touchmove', onMove, {passive:false});
  window.addEventListener('mouseup', onEnd, {passive:false});
  window.addEventListener('touchend', onEnd, {passive:false});
}

/* Extremos */
function goFirst(){ if(flipping) return; currentIndex = twoUp() ? -1 : 0; renderSpread(); }
function goLast(){
  if(flipping) return;
  if(!twoUp()) currentIndex = IMAGES.length - 1;
  else currentIndex = (IMAGES.length % 2 === 0) ? (IMAGES.length - 2) : (IMAGES.length - 3);
  renderSpread();
}

/* Auto pase */
function startAuto(){
  if(autoTimer) return;
  btnAuto.textContent = "Auto ‚è∏";
  autoTimer = setInterval(()=>{
    const before = currentIndex;
    goNext();
    if(before === currentIndex) stopAuto();
  }, 1800);
}
function stopAuto(){ if(autoTimer){ clearInterval(autoTimer); autoTimer=null; } btnAuto.textContent = "Auto ‚ñ∂"; }
btnAuto.addEventListener('click', ()=> autoTimer ? stopAuto() : startAuto());

/* Nav y teclado */
btnFirst.addEventListener('click', goFirst);
btnPrev .addEventListener('click', goPrev);
btnNext .addEventListener('click', goNext);
btnLast .addEventListener('click', goLast);

window.addEventListener('keydown', (e)=>{
  if(e.key==='ArrowLeft') goPrev();
  else if(e.key==='ArrowRight') goNext();
  else if(e.key==='Home') goFirst();
  else if(e.key==='End') goLast();
  else if((e.ctrlKey||e.metaKey) && (e.key==='=' || e.key==='+')) setZoom(userZoom+0.1);
  else if((e.ctrlKey||e.metaKey) && e.key==='-') setZoom(userZoom-0.1);
  else if((e.ctrlKey||e.metaKey) && e.key==='0') setZoom(1);
});

/* Responsivo */
let raf=0;
window.addEventListener('resize', ()=>{
  cancelAnimationFrame(raf);
  raf = requestAnimationFrame(()=>{
    const wasTwo = twoUp();
    currentIndex = wasTwo ? (currentIndex===0? -1: currentIndex) : (currentIndex===-1? 0: currentIndex);
    renderSpread();
  });
});

/* Detectar ratio real de la 1¬™ imagen y arrancar */
(function init(){
  const probe = new Image();
  probe.onload = ()=>{ if(probe.naturalHeight>0) ratio = probe.naturalWidth / probe.naturalHeight; renderSpread(); };
  probe.onerror = ()=>{ renderSpread(); };
  probe.src = IMAGES[0];
})();
</script>
</body>
</html>
